#!/usr/bin/env python3

import os
import re
import json
import time
import requests
import threading
from urllib.parse import urlparse, parse_qs
from concurrent.futures import ThreadPoolExecutor

try:
    from colorama import init, Fore, Style
    init(autoreset=True)
except ImportError:
    class Fore:
        RED = '\033[31m'
        GREEN = '\033[32m'
        YELLOW = '\033[33m'
        BLUE = '\033[34m'
        MAGENTA = '\033[35m'
        CYAN = '\033[36m'
        WHITE = '\033[37m'
        RESET = '\033[0m'
    
    class Style:
        BRIGHT = '\033[1m'
        RESET_ALL = '\033[0m'

import lib.core.settings
import lib.core.common


class VulnerabilityDetector:
    """
    AI-powered vulnerability detection engine for automated security assessment
    """
    
    def __init__(self, target_url, verbose=False, user_agent=None, proxy=None):
        self.target_url = target_url
        self.verbose = verbose
        self.user_agent = user_agent or lib.core.settings.DEFAULT_USER_AGENT
        self.proxy = proxy
        self.vulnerabilities = []
        self.session = requests.Session()
        self.session.headers.update({'User-Agent': self.user_agent})
        
        # Disable SSL verification for security testing
        self.session.verify = False
        
        # Disable SSL warnings  
        import urllib3
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        
        # Vulnerability patterns and signatures
        self.sql_patterns = [
            r"mysql_fetch_array\(\)",
            r"ORA-\d{5}",
            r"Microsoft.*ODBC.*SQL Server",
            r"PostgreSQL.*ERROR",
            r"Warning.*mysql_.*",
            r"valid MySQL result",
            r"MySqlClient\.",
            r"PostgreSQL query failed",
            r"unterminated quoted string at or near",
            r"'[^']*'[^']*'",
            r"syntax error at or near"
        ]
        
        self.xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')",
            "<svg/onload=alert('XSS')>",
            "';alert('XSS');//"
        ]
        
        self.lfi_payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "....//....//....//etc/passwd",
            "..%2F..%2F..%2Fetc%2Fpasswd"
        ]
        
        self.common_files = [
            "/robots.txt",
            "/.htaccess",
            "/web.config",
            "/crossdomain.xml",
            "/sitemap.xml",
            "/.git/config",
            "/.env",
            "/config.php",
            "/wp-config.php",
            "/admin.php",
            "/phpmyadmin/",
            "/adminer.php"
        ]

    def start_detection(self, urls_list=None):
        """
        Start comprehensive vulnerability detection
        """
        print(f"\n{Fore.CYAN}Zeus AI Vulnerability Detector Started{Style.RESET_ALL}")
        print(f"{Fore.BLUE}Target: {Fore.WHITE}{self.target_url}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}{'='*80}{Style.RESET_ALL}\n")
        
        if urls_list:
            target_urls = urls_list
        else:
            target_urls = [self.target_url]
        
        # Multi-threaded vulnerability scanning
        with ThreadPoolExecutor(max_workers=5) as executor:
            futures = []
            
            for url in target_urls:
                # Submit different types of scans
                futures.append(executor.submit(self.detect_sql_injection, url))
                futures.append(executor.submit(self.detect_xss, url))
                futures.append(executor.submit(self.detect_lfi, url))
                futures.append(executor.submit(self.detect_directory_traversal, url))
                futures.append(executor.submit(self.scan_common_files, url))
                futures.append(executor.submit(self.detect_server_info, url))
            
            # Collect results
            for future in futures:
                try:
                    result = future.result(timeout=30)
                    if result:
                        self.vulnerabilities.extend(result)
                except Exception as e:
                    if self.verbose:
                        print(f"{Fore.RED}Error in detection thread: {e}{Style.RESET_ALL}")
        
        return self.vulnerabilities

    def detect_sql_injection(self, url):
        """
        Detect SQL injection vulnerabilities using pattern matching and response analysis
        """
        print(f"{Fore.BLUE}[SQL] Scanning: {url}{Style.RESET_ALL}")
        vulnerabilities = []
        
        parsed_url = urlparse(url)
        if not parsed_url.query:
            return vulnerabilities
        
        params = parse_qs(parsed_url.query)
        
        sql_payloads = [
            "'",
            "1' OR '1'='1",
            "' UNION SELECT NULL--",
            "1; DROP TABLE users--",
            "' AND 1=1--",
            "' AND 1=2--"
        ]
        
        for param in params:
            for payload in sql_payloads:
                try:
                    test_params = params.copy()
                    test_params[param] = [payload]
                    test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}"
                    
                    response = self.session.get(test_url, params=test_params, timeout=10, verify=False)
                    
                    # Check for SQL error patterns
                    for pattern in self.sql_patterns:
                        if re.search(pattern, response.text, re.IGNORECASE):
                            vuln = {
                                'type': 'SQL Injection',
                                'severity': 'HIGH',
                                'url': url,
                                'parameter': param,
                                'payload': payload,
                                'pattern_matched': pattern,
                                'response_snippet': response.text[:200],
                                'timestamp': time.time()
                            }
                            vulnerabilities.append(vuln)
                            print(f"{Fore.RED}[VULN] SQL Injection found in parameter '{param}'{Style.RESET_ALL}")
                            break
                    
                    time.sleep(0.5)  # Rate limiting
                    
                except Exception as e:
                    if self.verbose:
                        print(f"{Fore.YELLOW}SQL test error for {param}: {e}{Style.RESET_ALL}")
        
        return vulnerabilities

    def detect_xss(self, url):
        """
        Detect Cross-Site Scripting (XSS) vulnerabilities
        """
        print(f"{Fore.BLUE}[XSS] Scanning: {url}{Style.RESET_ALL}")
        vulnerabilities = []
        
        parsed_url = urlparse(url)
        if not parsed_url.query:
            return vulnerabilities
        
        params = parse_qs(parsed_url.query)
        
        for param in params:
            for payload in self.xss_payloads:
                try:
                    test_params = params.copy()
                    test_params[param] = [payload]
                    test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}"
                    
                    response = self.session.get(test_url, params=test_params, timeout=10, verify=False)
                    
                    # Check if payload is reflected in response
                    if payload in response.text:
                        vuln = {
                            'type': 'Cross-Site Scripting (XSS)',
                            'severity': 'MEDIUM',
                            'url': url,
                            'parameter': param,
                            'payload': payload,
                            'reflected': True,
                            'timestamp': time.time()
                        }
                        vulnerabilities.append(vuln)
                        print(f"{Fore.YELLOW}[VULN] XSS found in parameter '{param}'{Style.RESET_ALL}")
                    
                    time.sleep(0.3)
                    
                except Exception as e:
                    if self.verbose:
                        print(f"{Fore.YELLOW}XSS test error for {param}: {e}{Style.RESET_ALL}")
        
        return vulnerabilities

    def detect_lfi(self, url):
        """
        Detect Local File Inclusion (LFI) vulnerabilities
        """
        print(f"{Fore.BLUE}[LFI] Scanning: {url}{Style.RESET_ALL}")
        vulnerabilities = []
        
        parsed_url = urlparse(url)
        if not parsed_url.query:
            return vulnerabilities
        
        params = parse_qs(parsed_url.query)
        
        for param in params:
            for payload in self.lfi_payloads:
                try:
                    test_params = params.copy()
                    test_params[param] = [payload]
                    test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}"
                    
                    response = self.session.get(test_url, params=test_params, timeout=10, verify=False)
                    
                    # Check for common file inclusion indicators
                    lfi_indicators = [
                        "root:x:0:0:",
                        "[fonts]",
                        "127.0.0.1",
                        "localhost",
                        "# Copyright"
                    ]
                    
                    for indicator in lfi_indicators:
                        if indicator in response.text:
                            vuln = {
                                'type': 'Local File Inclusion (LFI)',
                                'severity': 'HIGH',
                                'url': url,
                                'parameter': param,
                                'payload': payload,
                                'indicator_found': indicator,
                                'timestamp': time.time()
                            }
                            vulnerabilities.append(vuln)
                            print(f"{Fore.RED}[VULN] LFI found in parameter '{param}'{Style.RESET_ALL}")
                            break
                    
                    time.sleep(0.5)
                    
                except Exception as e:
                    if self.verbose:
                        print(f"{Fore.YELLOW}LFI test error for {param}: {e}{Style.RESET_ALL}")
        
        return vulnerabilities

    def detect_directory_traversal(self, url):
        """
        Detect directory traversal vulnerabilities
        """
        print(f"{Fore.BLUE}[DIR] Scanning: {url}{Style.RESET_ALL}")
        vulnerabilities = []
        
        directory_payloads = [
            "../",
            "..\\",
            "....//",
            "..%2F",
            "..%5C",
            "%2e%2e%2f",
            "%2e%2e%5c"
        ]
        
        base_url = url.rstrip('/')
        
        for payload in directory_payloads:
            try:
                test_url = f"{base_url}/{payload}etc/passwd"
                response = self.session.get(test_url, timeout=10, verify=False)
                
                if "root:x:0:0:" in response.text:
                    vuln = {
                        'type': 'Directory Traversal',
                        'severity': 'HIGH',
                        'url': test_url,
                        'payload': payload,
                        'timestamp': time.time()
                    }
                    vulnerabilities.append(vuln)
                    print(f"{Fore.RED}[VULN] Directory Traversal found{Style.RESET_ALL}")
                
                time.sleep(0.3)
                
            except Exception as e:
                if self.verbose:
                    print(f"{Fore.YELLOW}Directory traversal test error: {e}{Style.RESET_ALL}")
        
        return vulnerabilities

    def scan_common_files(self, url):
        """
        Scan for common sensitive files and directories
        """
        print(f"{Fore.BLUE}[FILES] Scanning: {url}{Style.RESET_ALL}")
        vulnerabilities = []
        
        base_url = url.rstrip('/')
        
        for file_path in self.common_files:
            try:
                test_url = f"{base_url}{file_path}"
                response = self.session.get(test_url, timeout=10, verify=False)
                
                if response.status_code == 200 and len(response.text) > 0:
                    severity = 'HIGH' if any(sensitive in file_path for sensitive in ['.env', 'config', '.git']) else 'MEDIUM'
                    
                    vuln = {
                        'type': 'Sensitive File Exposure',
                        'severity': severity,
                        'url': test_url,
                        'file_path': file_path,
                        'status_code': response.status_code,
                        'content_length': len(response.text),
                        'timestamp': time.time()
                    }
                    vulnerabilities.append(vuln)
                    print(f"{Fore.YELLOW}[VULN] Exposed file: {file_path}{Style.RESET_ALL}")
                
                time.sleep(0.2)
                
            except Exception as e:
                if self.verbose:
                    print(f"{Fore.YELLOW}File scan error for {file_path}: {e}{Style.RESET_ALL}")
        
        return vulnerabilities

    def detect_server_info(self, url):
        """
        Detect server information disclosure vulnerabilities
        """
        print(f"{Fore.BLUE}[INFO] Scanning: {url}{Style.RESET_ALL}")
        vulnerabilities = []
        
        try:
            response = self.session.get(url, timeout=10, verify=False)
            headers = response.headers
            
            # Check for information disclosure in headers
            info_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version', 'X-AspNetMvc-Version']
            
            for header in info_headers:
                if header in headers:
                    vuln = {
                        'type': 'Information Disclosure',
                        'severity': 'LOW',
                        'url': url,
                        'header': header,
                        'value': headers[header],
                        'timestamp': time.time()
                    }
                    vulnerabilities.append(vuln)
                    print(f"{Fore.CYAN}[INFO] Server info: {header}: {headers[header]}{Style.RESET_ALL}")
            
            # Check for directory listing
            if "<title>Index of /" in response.text or "Directory Listing For" in response.text:
                vuln = {
                    'type': 'Directory Listing',
                    'severity': 'MEDIUM',
                    'url': url,
                    'timestamp': time.time()
                }
                vulnerabilities.append(vuln)
                print(f"{Fore.YELLOW}[VULN] Directory listing enabled{Style.RESET_ALL}")
                
        except Exception as e:
            if self.verbose:
                print(f"{Fore.YELLOW}Server info scan error: {e}{Style.RESET_ALL}")
        
        return vulnerabilities

    def generate_report(self):
        """
        Generate a comprehensive vulnerability report
        """
        if not self.vulnerabilities:
            return None
        
        report = {
            'target': self.target_url,
            'scan_timestamp': time.time(),
            'total_vulnerabilities': len(self.vulnerabilities),
            'severity_breakdown': {
                'HIGH': len([v for v in self.vulnerabilities if v['severity'] == 'HIGH']),
                'MEDIUM': len([v for v in self.vulnerabilities if v['severity'] == 'MEDIUM']),
                'LOW': len([v for v in self.vulnerabilities if v['severity'] == 'LOW'])
            },
            'vulnerabilities': self.vulnerabilities
        }
        
        return report